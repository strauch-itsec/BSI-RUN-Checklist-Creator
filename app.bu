from flask import Flask, render_template, request, send_file, jsonify
import json
import os
import pandas as pd
from fpdf import FPDF
from docx import Document
from docx.shared import Inches

app = Flask(__name__)

# JSON-Datei laden mit Fehlerbehandlung
def load_json():
    try:
        if not os.path.exists("run_Anhang.json"):
            return {}
        
        with open("run_Anhang.json", "r", encoding="utf-8") as file:
            return json.load(file)
    except (json.JSONDecodeError, IOError) as e:
        print(f"Fehler beim Laden der JSON-Datei: {e}")
        return {}

# Startseite mit Filtermöglichkeiten
@app.route('/')
def index():
    data = load_json()
    categories = list(data.keys()) if data else []  # Themenbereiche
    return render_template("index.html", categories=categories)

# Gefilterte Anforderungen anzeigen
@app.route('/filter', methods=['POST'])
def filter_data():
    data = load_json()
    selected_grades = request.form.getlist("umsetzungsgrad")
    selected_category = request.form.get("category", "").strip()
    
    if not selected_category or selected_category not in data:
        return jsonify({"error": "Ungültige Kategorie"}), 400
    
    filtered = [req for req in data[selected_category] if req["Umsetzungsgrad"] in selected_grades]
    return jsonify(filtered)

# PDF-Export mit validierter Eingabe
@app.route('/export/pdf', methods=['POST'])
def export_pdf():
    try:
        filtered_data = json.loads(request.form.get("data", "[]"))
        category = request.form.get("category", "Keine Kategorie")
        grades = request.form.get("grades", "Keine Umsetzungsgrade")

        if not isinstance(filtered_data, list) or not filtered_data:
            return jsonify({"error": "Keine Daten zum Exportieren"}), 400

        class PDF(FPDF):
            def footer(self):
                self.set_y(-15)
                self.set_font('Arial', 'I', 8)
                self.cell(0, 10, 'Erstellt auf Basis Anlage BSI RUN, Stand 2025', 0, 0, 'C')
                self.ln(5)
                self.cell(0, 10, 'Disclaimer: Es wird keine Gewähr für die Richtigkeit der Daten übernommen.', 0, 0, 'C')

        pdf = PDF(orientation="L", unit="mm", format="A4")  # Querformat
        pdf.add_page()

        # Standard Arial-Schriftart für FPDF
        pdf.set_font('Arial', size=12)
        pdf.cell(0, 10, "Checkliste", ln=True, align="C")
        pdf.ln(10)

        # Kategorie und Umsetzungsgrade
        pdf.cell(0, 10, f"Kategorie: {category}", ln=True)
        pdf.cell(0, 10, f"Umsetzungsgrade: {grades}", ln=True)
        pdf.ln(10)

        # Kopfzeile
        pdf.set_font('Arial', size=12)
        pdf.multi_cell(30, 10, "Anforderungs-\nnummer", 1, 'C')
        pdf.multi_cell(100, 10, "Umsetzungs-\ngrad", 1, 'C')
        pdf.cell(40, 20, "Name", 1, 'C')
        pdf.cell(70, 20, "Status", 1, 'C')  # Spalte verbreitert und umbenannt
        pdf.ln(20)  # Die Höhe der Kopfzeile berücksichtigen

        # Datenzeilen
        for item in filtered_data:
            # Berechne die Höhe der MultiCell
            name_text = item['Name']
            lines = pdf.multi_cell(40, 7, name_text, border=0, align='L', split_only=True)
            name_height = len(lines) * 7
            row_height = max(10, name_height)

            # Überprüfe, ob der Seitenwechsel notwendig ist
            #if (pdf.get_y() + row_height + 20) > pdf.h - pdf.b_margin - 10:  # 20 für die Fußzeile, 10 Puffera
            if pdf.get_y() + row_height > pdf.page_break_trigger:
                pdf.add_page()
                # Kopfzeile erneut hinzufügen
                pdf.multi_cell(30, 10, "Anforderungs-\nnummer", 1, 'C')
                pdf.multi_cell(100, 10, "Umsetzungs-\ngrad", 1, 'C')
                pdf.cell(40, 20, "Name", 1, 'C')
                pdf.cell(70, 20, "Status", 1, 'C')  # Spalte verbreitert und umbenannt
                pdf.ln(20)  

            y_before = pdf.get_y()
            pdf.cell(30, row_height, item['Anforderungsnummer'], 1)
            x, y = pdf.get_x(), pdf.get_y()  # speichere aktuelle Position
            pdf.multi_cell(40, 7, name_text, 1, 'L')  # Text linksbündig, Zeilenabstand verkleinert
            y_after = pdf.get_y()
            row_height = y_after - y_before

            pdf.set_xy(x + 40, y_before)  # setze X-Position nach Namensfeld, Y bleibt gleich
            pdf.cell(100, row_height, item['Umsetzungsgrad'], 1)
            pdf.cell(70, row_height, "", 1)  # Verbreiterte Spalte ohne Häkchen

            # Gehe zur nächsten Zeile
            pdf.ln(row_height)

        pdf_path = "checkliste.pdf"
        pdf.output(pdf_path)
        return send_file(pdf_path, as_attachment=True)

    except Exception as e:
        return jsonify({"error": f"Fehler beim Exportieren: {str(e)}"}), 500


# Word-Export im Querformat mit Kopfzeilen
@app.route('/export/word', methods=['POST'])
def export_word():
    try:
        filtered_data = json.loads(request.form.get("data", "[]"))
        if not isinstance(filtered_data, list) or not filtered_data:
            return jsonify({"error": "Keine Daten zum Exportieren"}), 400

        doc = Document()
        section = doc.sections[0]
        section.orientation = 1  # Querformat
        section.page_width = Inches(11.69)
        section.page_height = Inches(8.27)

        doc.add_heading("Checkliste", level=1)

        table = doc.add_table(rows=1, cols=4)
        table.style = "Table Grid"

        hdr_cells = table.rows[0].cells
        hdr_cells[0].text = "Anforderungsnr."
        hdr_cells[1].text = "Name"
        hdr_cells[2].text = "Umsetzungsgrad"
        hdr_cells[3].text = "Auswahl"

        for item in filtered_data:
            row_cells = table.add_row().cells
            row_cells[0].text = item['Anforderungsnummer']
            row_cells[1].text = item['Name']
            row_cells[2].text = item['Umsetzungsgrad']
            row_cells[3].text = "✓"  # Checkbox als Haken

        doc_path = "checkliste.docx"
        doc.save(doc_path)
        return send_file(doc_path, as_attachment=True)

    except Exception as e:
        return jsonify({"error": f"Fehler beim Exportieren: {str(e)}"}), 500


if __name__ == '__main__':
    app.run(debug=True)

